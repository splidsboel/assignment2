/*
 * This source file was generated by the Gradle 'init' task
 */
package hyperloglog;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class HyperLogLog {

    // storing pre-specified hash seeds from assignment description
    private static final int[] hashIntegers = {
        0x21ae4036, 0x32435171, 0xac3338cf,
        0xea97b40c, 0x0e504b22, 0x9ff9a4ef,
        0x111d014d, 0x934f3787, 0x6cd079bf,
        0x69db5c31, 0xdf3c28ed, 0x40daf2ad,
        0x82a5891c, 0x4659c7b0, 0x73dc0ca8,
        0xdad3aca2, 0x00c74c7e, 0x9a2521e2,
        0xf38eb6aa, 0x64711ab6, 0x5823150a,
        0xd13a3a9a, 0x30a5aa04, 0x0fb9a1da,
        0xef785119, 0xc9f0b067, 0x1e7dde42,
        0xdda4a7b2, 0x1a1c2640, 0x297c0633,
        0x744edb48, 0x19adce93
    };

    private static final int DEFAULT_REGISTER_COUNT = 1024;
    private static final int DEFAULT_BUCKET_BITS = Integer.numberOfTrailingZeros(DEFAULT_REGISTER_COUNT);

    public HyperLogLog() {
        
    }


    
    /**
     * For each integer in A (hashIntegers array) we take the bitwise AND with x,
     * count the number of set bits in the result, extract the parity (whether it's even or odd), 
     * and set corresponding bit in the result hash. 
     * @param x
     * @return deterministic hash of x
     */
    public static int h(int x) {
        int hash = 0;
        for (int i = 0; i < hashIntegers.length; i++) {
            int parity = Integer.bitCount(hashIntegers[i] & x) & 1;
            hash |= parity << i;
        }
        return hash;
    }    

    public static int[] hArray(int[] x){
        return Arrays.stream(x)
            .map(HyperLogLog::h)
            .toArray();
    }


    public static int f(int x){
        return ((x*0xbc164501) & 0x7fffffff) >> 21;
    }

    /**
     * Since œÅ(x) is the position of the first 1 in the binary representation of 
     * the binary string x, we can user numberOfLeadingZeros on the input to see where the first 1 is in the bitstring
     * @param x
     * @return
     */
    public static int rho(int x) {
        if (x == 0) throw new IllegalArgumentException("rho(0) is undefined");
        return Integer.numberOfLeadingZeros(x) + 1;
    }

    private static void updateRegister(int[] registers, int value) {
        int registerCount = registers.length;
        if (registerCount <= 0) {
            throw new IllegalArgumentException("register count must be positive");
        }

        int registerBits = Integer.numberOfTrailingZeros(registerCount);
        if ((1 << registerBits) != registerCount) {
            throw new IllegalArgumentException("register count must be a power of two");
        }
        if (registerBits > DEFAULT_BUCKET_BITS) {
            throw new IllegalArgumentException("register count cannot exceed " + DEFAULT_REGISTER_COUNT);
        }

        int bucket = f(value);
        int shift = DEFAULT_BUCKET_BITS - registerBits;
        if (shift > 0) {
            bucket >>>= shift;
        }

        int hashed = h(value);
        registers[bucket] = Math.max(registers[bucket], rho(hashed));
    }

    private static double estimateFromRegisters(int[] registers) {
        int m = registers.length;
        double alphaM = 0.7213 / (1 + (1.079 / m));

        double sum = 0;
        int empty = 0;
        for (int registerValue : registers) {
            sum += Math.pow(2.0, -registerValue);
            if (registerValue == 0) {
                empty++;
            }
        }

        double estimate = (alphaM * m * m) / sum;
        if ((estimate <= (2.5 * m)) && empty > 0) {
            return m * Math.log((double) m / empty);
        }

        double twoTo32 = Math.pow(2.0, 32);
        if (estimate > ((1.0 / 30.0) * twoTo32)) {
            estimate = -twoTo32 * Math.log(1.0 - (estimate / twoTo32));
        }
        return estimate;
    }

    /**
     * overloaded hll with default m argument
     * @param Y
     * @return
     */
    public double hll(int[] Y){
        return hll(Y, DEFAULT_REGISTER_COUNT);
    }
    /**
     * implements hyperloglog using helper methods
     * @param Y
     * @param m
     * @return
     */
    public double hll(int[] Y, int m){
        if (m <= 0 || (m & (m - 1)) != 0) {
            throw new IllegalArgumentException("m must be a positive power of two");
        }
        if (m > DEFAULT_REGISTER_COUNT) {
            throw new IllegalArgumentException("m must not exceed " + DEFAULT_REGISTER_COUNT);
        }
        int[] registers = new int[m];
        for (int value : Y) {
            updateRegister(registers, value);
        }
        return estimateFromRegisters(registers);
    }
    

    public static int[] readData() {
        Scanner s = new Scanner(System.in);
        int[] x = null;
        try {
            int n = s.nextInt();
            x = new int[n];
            for (int i = 0; i < n; ++i) {
                x[i] = s.nextInt();
            }
        }
        finally {
            s.close();
        }
        return x;
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println("Missing mode argument.");
            System.out.println("null");
            return;
        }

        switch (args[0]) {
            case "hash": { //if the input begins with hash
                int[] x = readData();
                int[] hashed = hArray(x);
                if (hashed.length == 0) {
                    System.out.println("null");
                } else if (hashed.length < 3) {
                    StringBuilder builder = new StringBuilder();
                    for (int i = 0; i < hashed.length; i++) {
                        if (i > 0) {
                            builder.append(' ');
                        }
                        builder.append(hashed[i]);
                    }
                    System.out.println(builder.toString());
                } else {
                    System.out.println(String.format("%d %d %d",
                        hashed[0], hashed[1], hashed[2]));
                }
                break;
            }
            case "rho-dist": { //if the input starts with rho-dist
                int[] x = readData();
                int[] hashed = hArray(x);
                int[] counts = new int[33]; //indexes from 1-32 to store the rho counts

                for (int value : hashed) {
                   

                    int rhoValue = rho(value);
                    if (rhoValue >= counts.length) {
                        counts = Arrays.copyOf(counts, rhoValue + 1);
                    }
                    counts[rhoValue]++;
                }

                System.out.println("rho,count");
                for (int rhoValue = 1; rhoValue < counts.length; rhoValue++) {
                    System.out.printf("%d,%d%n", rhoValue, counts[rhoValue]);
                }
                break;
            }
            case "hash-sample": {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
                StringBuilder builder = new StringBuilder();
                boolean first = true;
                try {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        line = line.trim();
                        if (line.isEmpty()) {
                            continue;
                        }
                        int value;
                        try {
                            value = (int) Long.parseUnsignedLong(line, 16);
                        } catch (NumberFormatException ex) {
                            System.err.println("Invalid hex input: " + line);
                            System.out.println("null");
                            return;
                        }
                        int hashed = h(value);
                        if (!first) {
                            builder.append('\n');
                        } else {
                            first = false;
                        }
                        builder.append(String.format("%08x", hashed));
                    }
                    System.out.print(builder.toString());
                } catch (IOException e) {
                    System.err.println("Failed to read input: " + e.getMessage());
                    System.out.println("null");
                }
                break;
            }
            case "rho-sample": {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
                StringBuilder builder = new StringBuilder();
                boolean first = true;
                try {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        line = line.trim();
                        if (line.isEmpty()) {
                            continue;
                        }
                        int value;
                        try {
                            value = (int) Long.parseUnsignedLong(line, 16);
                        } catch (NumberFormatException ex) {
                            System.err.println("Invalid hex input: " + line);
                            System.out.println("null");
                            return;
                        }
                        if (value == 0) {
                            System.err.println("rho(0) is undefined for input: " + line);
                            System.out.println("null");
                            return;
                        }
                        int rhoValue = rho(value);
                        if (!first) {
                            builder.append('\n');
                        } else {
                            first = false;
                        }
                        builder.append(rhoValue);
                    }
                    System.out.print(builder.toString());
                } catch (IOException e) {
                    System.err.println("Failed to read input: " + e.getMessage());
                    System.out.println("null");
                }
                break;
            }
            case "registers-sample": {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
                int[] registers = new int[DEFAULT_REGISTER_COUNT];
                try {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        line = line.trim();
                        if (line.isEmpty()) {
                            continue;
                        }
                        int value;
                        try {
                            value = (int) Long.parseUnsignedLong(line, 16);
                        } catch (NumberFormatException ex) {
                            System.err.println("Invalid hex input: " + line);
                            System.out.println("null");
                            return;
                        }
                        updateRegister(registers, value);
                    }

                    StringBuilder builder = new StringBuilder();
                    for (int i = 0; i < registers.length; i++) {
                        if (i > 0) {
                            builder.append('\n');
                        }
                        builder.append(registers[i]);
                    }
                    System.out.print(builder.toString());
                } catch (IOException e) {
                    System.err.println("Failed to read input: " + e.getMessage());
                    System.out.println("null");
                }
                break;
            }
            case "threshold": {
                Scanner scanner = new Scanner(System.in);
                try {
                    if (!scanner.hasNextInt()) {
                        System.err.println("Missing threshold input.");
                        System.out.println("null");
                        break;
                    }

                    int threshold = scanner.nextInt();
                    int[] registers = new int[DEFAULT_REGISTER_COUNT];
                    while (scanner.hasNextInt()) {
                        int value = scanner.nextInt();
                        updateRegister(registers, value);
                    }

                    double estimate = estimateFromRegisters(registers);
                    if (estimate >= threshold) {
                        System.out.println("above");
                    } else {
                        System.out.println("below");
                    }
                } finally {
                    scanner.close();
                }
                break;
            }
            case "estimate": {
                if (args.length < 2) {
                    System.err.println("Missing register count for estimate mode.");
                    System.out.println("null");
                    break;
                }

                int m;
                try {
                    m = Integer.parseInt(args[1]);
                } catch (NumberFormatException ex) {
                    System.err.println("Invalid register count: " + args[1]);
                    System.out.println("null");
                    break;
                }

                if (m <= 0 || (m & (m - 1)) != 0 || m > DEFAULT_REGISTER_COUNT) {
                    System.err.println("Register count must be a power of two between 1 and " + DEFAULT_REGISTER_COUNT + ".");
                    System.out.println("null");
                    break;
                }

                int[] x = readData();
                HyperLogLog hll = new HyperLogLog();
                try {
                    double estimate = hll.hll(x, m);
                    System.out.println(estimate);
                } catch (IllegalArgumentException ex) {
                    System.err.println(ex.getMessage());
                    System.out.println("null");
                }
                break;
            }
            default: {
                System.err.println("Unknown mode: " + args[0]);
                System.out.println("null");
                break;
            }
        }
    }
}
